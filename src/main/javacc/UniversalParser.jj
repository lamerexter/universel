/*******************************************************************************
  ~  MIT Licence:
  ~
  ~  Copyright (c) 2018 Orthodox Engineering Ltd
  ~
  ~  Permission is hereby granted, free of charge, to any person
  ~  obtaining a copy of this software and associated documentation
  ~  files (the "Software"), to deal in the Software without restriction
  ~  including without limitation the rights to use, copy, modify, merge,
  ~  publish, distribute, sublicense, and/or sell copies of the Software,
  ~  and to permit persons to whom the Software is furnished to do so,
  ~  subject to the following conditions:
  ~
  ~  The above copyright notice and this permission notice shall be
  ~  included in all copies or substantial portions of the Software.
  ~
  ~  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
  ~  KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  ~  WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
  ~  PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  ~  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  ~  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  ~  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  ~  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  ~  DEALINGS IN THE SOFTWARE.
 ******************************************************************************/
//-------------------------------------------------------------------------------------------------
// Parser options
//-------------------------------------------------------------------------------------------------
options
{
   // Parser options:
   DEBUG_PARSER = false;                   // Whether the parser should output debugging information to diagnose problems.
   DEBUG_LOOKAHEAD = false;                // Whether the parser should output debugging information when making lookahead decisions.
   DEBUG_TOKEN_MANAGER = false;            // Whether the parser tokeniser should output debugging information to diagnose problems.
   LOOKAHEAD = 1;                          // The input stream symbol lookahead of the generated parser i.e. and LR(<nnn>) parser
   JAVA_UNICODE_ESCAPE = false;            // Whether Java Unicode sequences are expanded prior to transmission to the tokeniser.
   JDK_VERSION = "1.8";                    // The Java/JDK version of the parser to create
   UNICODE_INPUT = true;                   // Use a unicode capable input stream.
   FORCE_LA_CHECK = false;                 // Always carry out lookahead checking
   COMMON_TOKEN_ACTION=true;               // Call the CommonTokenAction token manager method on each token (special token processing)
}

PARSER_BEGIN(UniversalParser)
package org.orthodox.universal.parser;

import org.orthodox.universel.ast.*;
import org.orthodox.universel.ast.literals.*;import java.io.StringReader;

public class UniversalParser
{
    public UniversalParser(String input) {
        this(new StringReader(input));
    }

    TokenImage tokenImage() {
        return new TokenImage(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);
    }
}
PARSER_END(UniversalParser)

//-------------------------------------------------------------------------------------------------
// Lexical Analyser definitions and tokens
//-------------------------------------------------------------------------------------------------
TOKEN_MGR_DECLS:
{
    private void CommonTokenAction(Token token) {
    }
}

// Ignore whitespace tokens
SKIP :
{
   " " | "\t" | "\r" | "\n"
}

TOKEN :
{
  < BIGINTEGER_LITERAL: <INTEGER_LITERAL> "I" >
|
  < BINARY_LITERAL: "0" ["b","B"] ["0","1"]((["0","1","_"])*["0","1"])? >
|
  < INTEGER_LITERAL: ["0"-"9"]((["0"-"9","_"])*["0"-"9"])? >
|
  < #HEX_DIGITS: ["0"-"9","a"-"f","A"-"F"]((["0"-"9","a"-"f","A"-"F","_"])*["0"-"9","a"-"f","A"-"F"])? >
|
  < HEX_LITERAL: "0" ["x","X"] <HEX_DIGITS> >
|
  < OCTAL_LITERAL: "0" ["0"-"7"]((["0"-"7","_"])*["0"-"7"])? >
}

public Expression Literal():
{
	Expression ret;
}
{
  (
	  <INTEGER_LITERAL> {
	  		ret = new IntegerLiteralExpr(tokenImage());
	  }
	  |
	  <BIGINTEGER_LITERAL> {
	  		ret = new BigIntegerLiteralExpr(tokenImage());
	  }
//	|
//
//	  <INTEGER_LITERAL> {
//	  		ret = new IntegerLiteralExpr(tokenRange(), token.image);
//	  }
//	|
//	  <LONG_LITERAL> {
//	  		ret = new LongLiteralExpr(tokenRange(), token.image);
//	  }
//	|
//	  <FLOATING_POINT_LITERAL> {
//	  		ret = new DoubleLiteralExpr(tokenRange(), token.image);
//	  }
//	|
//	  <CHARACTER_LITERAL> {
//	  	ret = new CharLiteralExpr(tokenRange(), token.image.substring(1, token.image.length()-1));
//	  }
//	|
//	  <STRING_LITERAL> {
//	  	ret = new StringLiteralExpr(tokenRange(), token.image.substring(1, token.image.length()-1));
//	  }

//	|
//	  ret = BooleanLiteral()
//	|
//	  ret = NullLiteral()
  )
  { return ret; }
}


