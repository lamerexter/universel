/*******************************************************************************
  ~  MIT Licence:
  ~
  ~  Copyright (c) 2019 Orthodox Engineering Ltd
  ~
  ~  Permission is hereby granted, free of charge, to any person
  ~  obtaining a copy of this software and associated documentation
  ~  files (the "Software"), to deal in the Software without restriction
  ~  including without limitation the rights to use, copy, modify, merge,
  ~  publish, distribute, sublicense, and/or sell copies of the Software,
  ~  and to permit persons to whom the Software is furnished to do so,
  ~  subject to the following conditions:
  ~
  ~  The above copyright notice and this permission notice shall be
  ~  included in all copies or substantial portions of the Software.
  ~
  ~  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
  ~  KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  ~  WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
  ~  PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  ~  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  ~  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  ~  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  ~  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  ~  DEALINGS IN THE SOFTWARE.
 ******************************************************************************/
//-------------------------------------------------------------------------------------------------
// Parser options
//-------------------------------------------------------------------------------------------------
options
{
   // Parser options:
   DEBUG_PARSER = false;                   // Whether the parser should output debugging information to diagnose problems.
   DEBUG_LOOKAHEAD = false;                // Whether the parser should output debugging information when making lookahead decisions.
   DEBUG_TOKEN_MANAGER = false;            // Whether the parser tokeniser should output debugging information to diagnose problems.
   LOOKAHEAD = 1;                          // The input stream symbol lookahead of the generated parser i.e. and LR(<nnn>) parser
   JAVA_UNICODE_ESCAPE = false;            // Whether Java Unicode sequences are expanded prior to transmission to the tokeniser.
   JDK_VERSION = "1.8";                    // The Java/JDK version of the parser to create
   UNICODE_INPUT = true;                   // Use a unicode capable input stream.
   FORCE_LA_CHECK = true;                 // Always carry out lookahead checking
   COMMON_TOKEN_ACTION=true;               // Call the CommonTokenAction token manager method on each token (special token processing)
}

PARSER_BEGIN(UniversalParser)
package org.orthodox.universal.parser;

import java.util.List;
import java.util.ArrayList;
import org.orthodox.universel.ast.*;
import org.orthodox.universel.ast.literals.*;import java.io.StringReader;

public class UniversalParser
{
    public UniversalParser(String input) {
        this(new StringReader(input));
    }

    private TokenImage tokenImage() {
        return new TokenImage(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);
    }

   private <T> List<T> add(List<T> list, Object obj) {
      if (list == null) {
         list = new ArrayList<T>();
      }
      list.add((T)obj);
      return list;
   }
}
PARSER_END(UniversalParser)

//-------------------------------------------------------------------------------------------------
// Lexical Analyser definitions and tokens
//-------------------------------------------------------------------------------------------------
TOKEN_MGR_DECLS:
{
    private void CommonTokenAction(Token token) {
    }
}

// Ignore whitespace tokens
SKIP :
{
   " " | "\t" | "\r" | "\n"
}

/**
* Reserved words and literals.
*/
TOKEN :
{
  < NULL: "null" >
| < RBRACE: "}" >
}

/**
* Numeric literal tokens.
*/
TOKEN :
{
  < BOOLEAN_LITERAL: "true" | "false" >
| < #OCTAL_LITERAL: "0" ["0"-"7"]((["0"-"7","_"])*["0"-"7"])? >
| < OCTAL_INTEGER_LITERAL: <OCTAL_LITERAL> (["l","L"])? >
| < #BINARY_LITERAL: "0" ["b","B"] ["0","1"]((["0","1","_"])*["0","1"])? >
| < BINARY_INTEGER_LITERAL: <BINARY_LITERAL> (["l","L"])? >
| < #DECIMAL_LITERAL: ["0"-"9"]((["0"-"9","_"])*["0"-"9"])? >
| < DECIMAL_INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L","I"])? >
| < #HEX_DIGIT: ["0"-"9","a"-"f","A"-"F"] >
| < #HEX_DIGITS: <HEX_DIGIT> ((["0"-"9","a"-"f","A"-"F","_"])*<HEX_DIGIT>)? >
| < #HEX_LITERAL: "0" ["x","X"] <HEX_DIGITS> >
| < HEX_INTEGER_LITERAL: <HEX_LITERAL> (["l","L"])? >
| < DECIMAL_FLOATING_POINT_LITERAL:
      <DECIMAL_INTEGER_LITERAL> "." (<DECIMAL_INTEGER_LITERAL>)? (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
    | "." <DECIMAL_INTEGER_LITERAL> (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
    | <DECIMAL_INTEGER_LITERAL> <DECIMAL_EXPONENT> (["f","F","d","D"])?
    | <DECIMAL_INTEGER_LITERAL> (<DECIMAL_EXPONENT>)? ["f","F","d","D"]
  >

| < #DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (<DECIMAL_INTEGER_LITERAL>)+ >
| < HEX_FLOATING_POINT_LITERAL:
      <HEX_INTEGER_LITERAL> (".")? <HEX_EXPONENT> (["f","F","d","D"])?
    | "0" ["x","X"] (<HEX_DIGITS>)? "." <HEX_DIGITS> <HEX_EXPONENT> (["f","F","d","D"])?
  >
| < #HEX_EXPONENT: ["p","P"] (["+","-"])? <DECIMAL_INTEGER_LITERAL> >
}

/**
* String and character sequence literal tokens.
*/
TOKEN :
{
  < #UNICODE_ESCAPE: "\\u" <HEX_DIGIT> <HEX_DIGIT> <HEX_DIGIT> <HEX_DIGIT> >
|
  < SQ_STRING:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
        | <UNICODE_ESCAPE>
      )*
      "'"
  >
|
  < TQ_STRING:
      "'''"
      (   (~["'","\\"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
        | "'"
        | <UNICODE_ESCAPE>
      )*
      "'''"
  >
|
  < DQ_INTERP_STRING_START: "\"" > : WITHIN_DQ_INTERP_STRING
}

<WITHIN_DQ_INTERP_STRING> TOKEN :
{
  <DQ_INTERP_STRING_COMPLEX_EXPR_START: "${"> : DEFAULT
  |
  <DQ_INTERP_STRING_CHAR:
    (
        ~["\"","\\","\n","\r"]
        | "$"
        | (
            "\\"
            ( ["n","t","b","r","f","\\","'","\"", "$"]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
        | <UNICODE_ESCAPE>
    )
  >
  |
  <DQ_INTERP_STRING_END: "\""> : DEFAULT
}

<WITHIN_DQ_INTERP_STRING_COMPLEX_EXPR > MORE :
{
    <DQ_INTERP_STRING_COMPLEX_EXPR_CHAR: (~[])>
}


public Expression Literal():
{
	Expression ret;
}
{
  (
      <BOOLEAN_LITERAL > { ret = new BooleanLiteralExpr(tokenImage()); }
      |
	  <BINARY_INTEGER_LITERAL> { ret = new BinaryLiteralExpr(tokenImage()); }
	  |
	  <DECIMAL_INTEGER_LITERAL> { ret = new DecimalIntegerLiteralExpr(tokenImage()); }
	  |
	  <HEX_INTEGER_LITERAL> { ret = new HexadecimalIntegerLiteralExpr(tokenImage()); }
	  |
	  <OCTAL_INTEGER_LITERAL> { ret = new OctalIntegerLiteralExpr(tokenImage()); }
	  |
	  <DECIMAL_FLOATING_POINT_LITERAL> { ret = new DecimalFloatingPointLiteralExpr(tokenImage()); }
	  |
	  <HEX_FLOATING_POINT_LITERAL> { ret = new HexadecimalFloatingPointLiteralExpr(tokenImage()); }
	  |
	  <NULL> { ret = new NullLiteralExpr(tokenImage()); }
	  |
	  <SQ_STRING> { ret = new StringLiteralExpr(tokenImage(), "'"); }
	  |
	  <TQ_STRING> { ret = new StringLiteralExpr(tokenImage(), "'''"); }
	  |
	  ret=InterpolatedStringLiteral()
//	|
//
//	  <INTEGER_LITERAL> {
//	  		ret = new DecimalIntegerLiteralExpr(tokenRange(), token.image);
//	  }
//	|
//	  <LONG_LITERAL> {
//	  		ret = new DecimalLongLiteralExpr(tokenRange(), token.image);
//	  }
//	|
//	  <FLOATING_POINT_LITERAL> {
//	  		ret = new DoubleLiteralExpr(tokenRange(), token.image);
//	  }
//	|
//	  <CHARACTER_LITERAL> {
//	  	ret = new CharLiteralExpr(tokenRange(), token.image.substring(1, token.image.length()-1));
//	  }

//	|
//	  ret = BooleanLiteral()
//	|
//	  ret = NullLiteral()
  )
  { return ret; }
}

Expression InterpolatedStringLiteral() :
{
    Node part = null;
    List<Node> parts = null;
    StringBuilder s = new StringBuilder();
    int startLine = -1, endLine = -1, startColumn = -1, endColumn = -1;
}
{
    <DQ_INTERP_STRING_START> { startLine=token.beginLine; startColumn=token.beginColumn; s.append("\""); }
    (
        <DQ_INTERP_STRING_CHAR> { parts=add(parts, new StringLiteralExpr(tokenImage())); s.append(token.image); }
        |
        (
            <DQ_INTERP_STRING_COMPLEX_EXPR_START>

            (part=Literal() { parts=add(parts, part); s.append(part.getTokenImage().getImage()); })?

            <RBRACE> { token_source.SwitchTo(WITHIN_DQ_INTERP_STRING); }
        )
    )*
    <DQ_INTERP_STRING_END>
    {

        endLine=token.endLine; endColumn=token.endColumn; s.append("\"");
        return new InterpolatedStringLiteralExpr(new TokenImage(startLine, startColumn, endLine, endColumn, s.toString()), parts);
    }
}


